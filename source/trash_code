
       DRAW TETRAHEDRONS CODE



       // tetrahedron data
           /*
           unsigned int tVBOs[1000];
           unsigned int tVAOs[1000];
           unsigned int tEBOs[1000];
            */


        /*
        for(int i = 0; i < mesh.getFaces().size(); i++) {
            glm::vec3 t[4] = {mesh.getVertices()[mesh.getFaces()[i].x - 1],
                          mesh.getVertices()[mesh.getFaces()[i].y - 1],
                          mesh.getVertices()[mesh.getFaces()[i].z - 1],
                          {tetrahedron_vertex[0], tetrahedron_vertex[1], tetrahedron_vertex[2] }};
            tetrahedron tetrahedron = {t[0], t[1], t[2], t[3]};
            float volume = Mesh::tetrahedronVolume(tetrahedron);

            const float green[4] = {0.f, 1.f, 0.f, 1.f};
            const float red[4] = {1.f, 0.f, 0.f, 1.f};

            if(volume >= 0) glUniform4fv(glGetUniformLocation(tetra_shader.programID, "color"), 1, green);
            else glUniform4fv(glGetUniformLocation(tetra_shader.programID, "color"), 1, red);

            unsigned int f[12] = {0, 1, 2, 0, 1, 3, 1, 2, 3, 2, 0, 3};
            glBindVertexArray(tVAOs[i]);
            glBindBuffer(GL_ARRAY_BUFFER, tVBOs[i]);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, tEBOs[i]);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, 12 * sizeof(int), f, GL_DYNAMIC_DRAW);
            glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * 4, t, GL_DYNAMIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glm::vec3), nullptr);
            glEnableVertexAttribArray(0);
            glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, nullptr);
        }
         */



                 /* GLM::LOOK AT METHOD
                 glm::vec4 camTransform = glm::vec4(cam_position.x, cam_position.y, cam_position.z, 1.0f);
                 glm::vec3 v_up = glm::vec3{0.f, 1.f, 0.f};
                 camTransform = camRotationY * camRotationX * camTransform;
                 auto viewMatrix = glm::lookAt(
                         glm::vec3{camTransform.x, camTransform.y, camTransform.z},
                         glm::vec3{0.f, 0.f, 0.f},
                         v_up
                         );
                 */